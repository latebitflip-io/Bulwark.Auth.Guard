# Bulwark.Auth.Guard (BETA)

Is a client .net library for `Bulwark.Auth` which is a JWT based api developer focused auth subsystem.
Please see: https://github.com/lateflip-io/Bulwark.Auth

# Contributing
- Each contribution will need a issue/ticket created to track the feature or bug fix before it will be considered
- The PR must pass all tests and be reviewed by an official maintainer
- Each PR must be linked to an issue/ticket, once the PR is merged the ticket will be auto closed
- Each feature/bugfix needs to have unit tests
- Each feature must have the code documented inline

There is a docker compose file in the root of the project that `must` be used to run the tests.
This can be started by running `docker-compose up` in the root of the project.
Mocks are not used in `Guard` tests, `Bulwark.Auth` must be running and in test mode. Test mode just allows easy 
extraction of tokens from emails sent out. This is all handled by starting the services with 
docker compose.

The Reason mocks are not used in most cases is good to verify the integration with `Bulwark.Auth` is working
with the latest version. It removes the false sense of security that comes with mocking. 

## Usage

Add the package to your project:
https://www.nuget.org/packages/Bulwark.Auth.Guard

`Bulwark.Auth` must be setup and running and should be accessible via a public url or 
internal network.
    
```csharp
// Create a new instance of the client
var guard  = new Guard("http://localhost:8080");
if(guard.IsHealty())
{
    Console.WriteLine("Bulwark.Auth is up and running");
}
else
{
    Console.WriteLine("Bulwark.Auth is not running");
}
```

`Guard` is currently used for two major areas of functionality: 

## Account management and administration summary 

It allows users to create and manage their accounts, including tasks such as changing passwords or email addresses. 
These changes can only be made if the userâ€™s account is verified and the user has a valid JWT token.

An account can be created in the traditional way by signing up with an email address (username is not supported) and password. 
This will trigger an email to be sent to the user with a verification link.

Alternatively, users can log in with Social Sign-In options. After authenticating through Google, Microsoft, or GitHub, 
submitting the ID token or access token from the provider to Bulwark.Auth will validate it against the provider 
and create an account for the user. If an account with the same email already exists, it will be linked. 
When logging in with a Social Sign-In, accounts created through Bulwark.Auth do not require email verification and are automatically verified.

However, signing up with an email and password requires email verification before the account is fully active.

## Authentication and Acknowledgement summary

Once an account is created and verified, users can log in through several methods: traditional username and password, 
magic code (sent via email by Bulwark.Auth), or social sign-in. Upon successful login, the system returns a payload 
containing a JWT access token and a refresh token. To enable the use of these tokens, they must be acknowledged with a device ID. 

The device ID is generated by the client application, which is useful for supporting multiple devices. Once acknowledged, 
the access token can be used to access protected resources.

The access token is short-lived, and when it expires, the longer-lived refresh token can be used to obtain a new access token. 
If the refresh token also expires, the user will be logged out of the client application and required to log in again.

For users who created their account via social sign-in, no password is initially set. 
However, if they wish to log in with a password, they can use the "forgot password" flow to create one.

## JWT Token Validation
Once a authenticated payload is acknowledged a access token can be validated server side. 
It is good to validated access tokens periodically to ensure they are still valid and haven't been tampered
with. Server side validation will check for revocation, expiration, and more.
        
```csharp
try
{
    var jwtInfo = await guard.Authenticate.ValidateAccessToken("test@latflip.io",
        authenticated.AccessToken, "deviceId");
}
catch(BulwarkException exception)
{
    // The token is invalid
}

```

The `Guard` client can be used to validate access tokens without server side validation. This is useful
for client side validation to reduce round trips to the server. But you don't get deep validation if
a token has been revoked or an account disabled. You will need to initialize
local validation which will cache the public signing key.


```csharp
// Initializing local validation only needs to be done once per lifetime of the client
guard.Authenticate.InitializeLocalKeyValidation();

var jwtInfo =
    guard.Authenticate.ValidateAccessTokenClientSide(authenticated.AccessToken);

```

Client validation does not require a token to be acknowledged, but it is recommended to acknowledge
a token in case you need to revoke it and need server side validation. Client side validation
will only validate expiration and signature. Also you cannot refresh an access token without acknowledging.



